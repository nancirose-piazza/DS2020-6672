import numpy as np
from gym_malware.envs.utils import interface, pefeatures
from gym_malware.envs.controls import manipulate2 as manipulate

from gym_malware import sha256_train, sha256_holdout, MAXTURNS, sha256_full
from collections import defaultdict

from keras.models import load_model
import os

current_set=sha256_full

ACTION_LOOKUP = {i: act for i, act in enumerate(manipulate.ACTION_TABLE.keys())}

def evaluate( action_function ):
    success=[]
    misclassified = []
    for sha256 in current_set:
        success_dict = defaultdict(list)
        bytez = interface.fetch_file(sha256)
        label = interface.get_label_local(bytez)
        if label == 0.0:
            misclassified.append(sha256)
            continue # already misclassified, move along
        for _ in range(MAXTURNS):
            action = action_function( bytez )
            print(action)
            success_dict[sha256].append(action)
            bytez = manipulate.modify_without_breaking( bytez, [action] )
            new_label = interface.get_label_local( bytez )   # test against local classifier
            if new_label == 0.0:
                success.append(success_dict)
                break
    return success, misclassified # evasion accuracy is len(success) / len(sha256_holdout)


if __name__ == '__main__':
    # baseline: choose actions at random
    random_action = lambda bytez: np.random.choice( list(manipulate.ACTION_TABLE.keys()) )
    random_success, misclassified = evaluate( random_action )
    total = len(current_set) - len(misclassified) # don't count misclassified towards success

    # option 1: Boltzmann sampling from Q-function network output
    softmax_max = 0
    softmax = lambda x : np.exp( x ) / np.sum( np.exp( x ))
    boltzmann_action = lambda x : np.random.choice( range(len(x)), p=softmax(x).flatten()) 
    # option 2: maximize the Q value, ignoring stochastic action space
    best_action = lambda x : np.argmax( x )

    fe = pefeatures.PEFeatureExtractor()
    def model_policy(model):
        shp = (1,) + tuple(model.input_shape[1:])
        def f(bytez):
            # first, get features from bytez
            feats = fe.extract( bytez )
            q_values = model.predict(feats.reshape(shp))[0]
            softmax_max = np.max(q_values)
            action_index = boltzmann_action( (q_values - softmax_max) ) # alternative: best_action
            return ACTION_LOOKUP[ action_index ]
        return f

    # compare to keras models with windowlength=1
    # dqn = load_model('gym-malware-master/models/dqn.h5')
    # dqn_success, _ = evaluate( model_policy(dqn) )
    dqn_score = sorted ( os.listdir('gym-malware-master/savepoint/models') )[-1]

    dqn_score = load_model('gym-malware-master/savepoint/models/'+dqn_score)
    dqn_score_success, _ = evaluate( model_policy(dqn_score) )
    print("RESULT-RANDOM")
    print(random_success)
    print("RESULT2")
    print(dqn_score_success)

    with open("gym-malware-master/successful_actions_log.txt", 'a') as logfile:
        logfile.write("\n\nSuccessful (random):\n")
        if len(random_success) > 0:
          for s in random_success:
            for i in s:
              logfile.write("("+i + "," + str(s[i])+")\n")
        else:
          logfile.write("None\n")
        logfile.write("\nSuccessful (score):\n")
        if len(dqn_score_success) > 0:
          for s in dqn_score_success:
            for i in s:
              logfile.write("("+i + "," + str(s[i])+")\n")
          logfile.close()
        else:
          logfile.write("None\n")
    # let's compare scores
    with open("gym-malware-master/log_test_all.txt", 'a') as logfile:
        logfile.write("\n\n\nSuccess rate (random chance): {}\n".format( len(random_success) /  total ))
        logfile.write("That is: " + str(len(random_success)) + " out of " + str(total))
        logfile.write("\nSuccess rate (dqn_score): {}".format( len(dqn_score_success) / total ) )          
        logfile.write("\nThat is: " + str(len(dqn_score_success)) + " out of " + str(total))
    print("Success rate of random chance: {}\n".format( len(random_success) / total ))
    print("That is: " + str(len(random_success)) + " out of " + str(total))
    print("\nSuccess rate (dqn_score): {}\n".format( len(dqn_score_success) / total ) )          
    print("That is: " + str(len(dqn_score_success)) + " out of " + str(total))